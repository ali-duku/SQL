<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Duplexer Sport SQL Explorer</title>
  <style>
    :root {
      --bg: #0a0f16;
      --panel: #121a24;
      --ink: #dce7f5;
      --ink-soft: #8ea0b8;
      --accent: #2bc48a;
      --accent-2: #2a8bdc;
      --line: #243244;
      --warn: #ff7a7a;
    }
    * { box-sizing: border-box; }
    html, body {
      height: 100%;
      overflow: hidden;
    }
    body {
      margin: 0;
      font-family: "IBM Plex Sans", "Segoe UI", sans-serif;
      color: var(--ink);
      background:
        radial-gradient(circle at 8% 8%, rgba(43,196,138,0.12) 0%, rgba(43,196,138,0) 34%),
        radial-gradient(circle at 92% 0%, rgba(42,139,220,0.12) 0%, rgba(42,139,220,0) 36%),
        var(--bg);
      min-height: 100vh;
    }
    .shell {
      display: grid;
      grid-template-columns: 300px 1fr;
      gap: 12px;
      padding: 12px;
      height: 100vh;
      overflow: hidden;
    }
    .panel {
      background: var(--panel);
      border: 1px solid var(--line);
      border-radius: 12px;
      box-shadow: 0 8px 24px rgba(10, 38, 29, 0.05);
    }
    .sidebar {
      display: grid;
      grid-template-rows: auto auto auto 1fr;
      overflow: hidden;
      min-height: 0;
    }
    .pane-title {
      margin: 0;
      padding: 12px 14px;
      border-bottom: 1px solid var(--line);
      font-size: 14px;
      letter-spacing: 0.02em;
      text-transform: uppercase;
    }
    .stats {
      padding: 10px 14px;
      border-bottom: 1px solid var(--line);
      font-size: 13px;
      color: var(--ink-soft);
      line-height: 1.6;
    }
    .sidebar-search {
      padding: 10px 14px;
      border-bottom: 1px solid var(--line);
      display: grid;
      gap: 8px;
      align-content: start;
    }
    .sidebar-search input {
      width: 100%;
      max-width: 100%;
      min-width: 0;
      height: 34px;
    }
    .tables-wrap {
      overflow: auto;
      padding: 6px 0;
      min-height: 0;
    }
    .table-btn {
      width: 100%;
      border: 0;
      background: transparent;
      color: var(--ink);
      text-align: left;
      padding: 8px 14px;
      cursor: pointer;
      font-size: 13px;
      border-left: 3px solid transparent;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .table-btn:hover { background: #182330; }
    .table-btn.active {
      background: #1a2a25;
      border-left-color: var(--accent);
      font-weight: 600;
    }
    .main {
      display: grid;
      grid-template-rows: auto auto auto minmax(320px, 1fr);
      gap: 12px;
      min-height: 0;
      overflow: hidden;
    }
    .header {
      padding: 12px 14px;
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
    }
    .header h1 {
      font-size: 18px;
      margin: 0;
      font-weight: 700;
      letter-spacing: 0.01em;
    }
    .header-left {
      display: flex;
      align-items: center;
      min-width: 0;
    }
    .header-actions {
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }
    .version-badge {
      display: inline-flex;
      align-items: center;
      height: 30px;
      padding: 0 10px;
      border-radius: 999px;
      border: 1px solid #2e4358;
      background: #0f1a26;
      color: #9dc6ee;
      font-size: 12px;
      font-weight: 600;
      letter-spacing: 0.02em;
    }
    .muted { color: var(--ink-soft); font-size: 12px; }
    .query-box { padding: 12px; }
    .toolbar {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-bottom: 8px;
      align-items: center;
    }
    select, button, input {
      border: 1px solid var(--line);
      border-radius: 8px;
      padding: 7px 10px;
      font: inherit;
      font-size: 13px;
      line-height: 1.2;
      background: #0f1620;
      color: var(--ink);
    }
    button.primary {
      background: linear-gradient(135deg, var(--accent), var(--accent-2));
      color: #fff;
      border: 0;
      font-weight: 600;
      cursor: pointer;
    }
    button.ghost { cursor: pointer; }
    textarea {
      width: 100%;
      min-height: 150px;
      resize: vertical;
      border: 1px solid var(--line);
      border-radius: 10px;
      padding: 10px;
      font-family: "Consolas", "Cascadia Mono", monospace;
      font-size: 13px;
      line-height: 1.45;
      color: var(--ink);
      background: #0d141d;
    }
    .sql-editor-wrap {
      position: relative;
    }
    .sql-autocomplete {
      position: absolute;
      left: 0;
      right: 0;
      top: calc(100% + 6px);
      z-index: 50;
      background: #101923;
      border: 1px solid var(--line);
      border-radius: 10px;
      box-shadow: 0 10px 24px rgba(0, 0, 0, 0.35);
      max-height: 230px;
      overflow: auto;
      display: none;
    }
    .sql-autocomplete.show {
      display: block;
    }
    .sql-suggest {
      width: 100%;
      border: 0;
      border-bottom: 1px solid #1f2d3d;
      background: transparent;
      color: var(--ink);
      text-align: left;
      padding: 8px 10px;
      cursor: pointer;
      font-size: 12px;
      font-family: "Consolas", "Cascadia Mono", monospace;
    }
    .sql-suggest:last-child {
      border-bottom: 0;
    }
    .sql-suggest:hover,
    .sql-suggest.active {
      background: #1a2a25;
    }
    .sql-suggest .kind {
      color: var(--ink-soft);
      margin-left: 8px;
      font-family: "IBM Plex Sans", "Segoe UI", sans-serif;
      font-size: 11px;
    }
    .status {
      padding: 8px 12px;
      font-size: 13px;
      border: 1px solid var(--line);
      border-radius: 10px;
      background: #0f1620;
      color: var(--ink-soft);
      min-height: 38px;
      display: flex;
      align-items: center;
    }
    .status.error {
      color: var(--warn);
      background: #2a1515;
      border-color: #5b2a2a;
    }
    .schema-wrap {
      padding: 8px;
      overflow: auto;
      min-height: 0;
      height: 100%;
    }
    #schemaSvg {
      width: 100%;
      height: 100%;
      min-height: 280px;
      border-radius: 10px;
      background: #0d141d;
      border: 1px solid var(--line);
    }
    .result-wrap {
      overflow: auto;
      padding: 0;
      min-height: 0;
      position: relative;
      background: #0f1620;
      height: 100%;
    }
    .view-panel {
      display: grid;
      grid-template-rows: auto auto minmax(0, 1fr);
      min-height: 0;
      overflow: hidden;
    }
    .view-tabs {
      display: flex;
      gap: 8px;
      padding: 8px 10px 0;
    }
    .view-tab {
      border: 1px solid var(--line);
      border-bottom: 0;
      border-radius: 8px 8px 0 0;
      padding: 7px 12px;
      background: #0f1620;
      color: var(--ink-soft);
      cursor: pointer;
      font-size: 12px;
      font-weight: 600;
    }
    .view-tab.active {
      background: #162331;
      color: var(--ink);
      border-color: #2f4358;
    }
    .view-meta {
      padding: 8px 12px;
      border-top: 1px solid var(--line);
      border-bottom: 1px solid var(--line);
      min-height: 34px;
      display: flex;
      align-items: center;
    }
    .view-body {
      min-height: 0;
      overflow: hidden;
    }
    .view-pane {
      display: none;
      min-height: 0;
      height: 100%;
    }
    .view-pane.active {
      display: block;
    }
    table {
      width: 100%;
      border-collapse: separate;
      border-spacing: 0;
      font-size: 12px;
      background: #0f1620;
      margin: 0;
    }
    th, td {
      border: 1px solid var(--line);
      padding: 6px 8px;
      text-align: left;
      white-space: nowrap;
    }
    th {
      position: sticky;
      top: 0;
      background: #162331;
      z-index: 5;
      box-shadow: none;
      background-clip: padding-box;
      transform: translateZ(0);
      will-change: transform;
    }
    .th-inner {
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }
    .col-menu-btn {
      border: 0;
      background: transparent;
      color: var(--ink-soft);
      font-size: 11px;
      line-height: 1;
      padding: 0 2px;
      cursor: pointer;
    }
    .col-menu-btn:hover {
      color: var(--ink);
    }
    .col-menu-btn.active {
      color: #64d9aa;
    }
    .col-menu-pop {
      position: fixed;
      z-index: 90;
      width: 250px;
      max-height: 420px;
      background: #1a1f25;
      border: 1px solid #2f343b;
      border-radius: 8px;
      box-shadow: 0 14px 30px rgba(0, 0, 0, 0.45);
      color: #e8eaed;
      display: none;
      overflow: hidden;
    }
    .col-menu-pop.show {
      display: block;
    }
    .col-menu-head {
      padding: 8px 0;
      border-bottom: 1px solid #2f343b;
    }
    .col-menu-action {
      width: 100%;
      border: 0;
      background: transparent;
      color: #e8eaed;
      text-align: left;
      padding: 8px 14px;
      cursor: pointer;
      font-size: 16px;
      font-family: "Roboto", "Segoe UI", sans-serif;
    }
    .col-menu-action:hover {
      background: #2b3138;
    }
    .col-menu-body {
      padding: 10px 12px 8px 12px;
      border-bottom: 1px solid #2f343b;
    }
    .menu-title {
      font-size: 14px;
      margin-bottom: 8px;
      color: #e8eaed;
      font-family: "Roboto", "Segoe UI", sans-serif;
    }
    .menu-links {
      font-size: 13px;
      margin-bottom: 8px;
      font-family: "Roboto", "Segoe UI", sans-serif;
    }
    .menu-links a {
      color: #8ab4f8;
      cursor: pointer;
      text-decoration: underline;
    }
    .menu-search {
      width: 100%;
      height: 36px;
      padding: 6px 8px;
      border: 1px solid #3c4043;
      border-radius: 6px;
      background: #202124;
      color: #e8eaed;
      font-size: 14px;
      margin-bottom: 8px;
      font-family: "Roboto", "Segoe UI", sans-serif;
    }
    .menu-values {
      max-height: 190px;
      overflow: auto;
      border: 1px solid #2f343b;
      border-radius: 6px;
      background: #1a1f25;
    }
    .menu-val-item {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 8px;
      font-size: 15px;
      font-family: "Roboto", "Segoe UI", sans-serif;
    }
    .menu-val-item:hover {
      background: #2b3138;
    }
    .menu-val-item input {
      accent-color: #8ab4f8;
    }
    .menu-footer {
      display: flex;
      justify-content: flex-end;
      gap: 10px;
      padding: 10px 12px;
    }
    .menu-footer button {
      min-width: 74px;
      border-radius: 6px;
      font-family: "Roboto", "Segoe UI", sans-serif;
    }
    .menu-footer .cancel {
      background: #e8eaed;
      color: #202124;
      border: 1px solid #c7c9cc;
    }
    .menu-footer .ok {
      background: #1e8e3e;
      color: #fff;
      border: 1px solid #1e8e3e;
    }
    .modal-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(4, 10, 18, 0.72);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 120;
      padding: 16px;
    }
    .modal-backdrop.show {
      display: flex;
    }
    .modal-card {
      width: min(760px, 100%);
      max-height: min(84vh, 900px);
      background: #121a24;
      border: 1px solid var(--line);
      border-radius: 12px;
      box-shadow: 0 18px 40px rgba(0, 0, 0, 0.5);
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    .modal-head {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px 14px;
      border-bottom: 1px solid var(--line);
      background: #14202d;
    }
    .modal-head h3 {
      margin: 0;
      font-size: 15px;
      font-weight: 700;
    }
    .modal-close {
      border: 0;
      background: transparent;
      color: var(--ink-soft);
      font-size: 22px;
      line-height: 1;
      cursor: pointer;
      padding: 0 4px;
    }
    .modal-close:hover {
      color: var(--ink);
    }
    .modal-body {
      padding: 10px 14px 14px 14px;
      overflow: auto;
      min-height: 0;
    }
    .release-item {
      border: 1px solid #223244;
      background: #0f1620;
      border-radius: 10px;
      padding: 10px 12px;
      margin-bottom: 10px;
    }
    .release-item:last-child {
      margin-bottom: 0;
    }
    .release-head {
      display: flex;
      align-items: baseline;
      justify-content: space-between;
      gap: 8px;
      margin-bottom: 6px;
    }
    .release-version {
      font-weight: 700;
      color: #9dc6ee;
      font-size: 13px;
    }
    .release-date {
      color: var(--ink-soft);
      font-size: 12px;
    }
    .release-item ul {
      margin: 0;
      padding-left: 18px;
      color: var(--ink);
      font-size: 12px;
      line-height: 1.5;
    }
    @media (max-width: 980px) {
      .shell { grid-template-columns: 1fr; }
      .sidebar { min-height: 220px; }
      .main { grid-template-rows: auto auto auto minmax(260px, 1fr); }
    }
  </style>
</head>
<body>
  <div class="shell">
    <aside class="panel sidebar">
      <h2 class="pane-title">Tables</h2>
      <div class="stats" id="stats">Loading...</div>
      <div class="sidebar-search">
        <input id="tableSearch" type="text" placeholder="Search tables..." />
        <input id="columnSearch" type="text" placeholder="Search columns..." />
      </div>
      <div class="tables-wrap" id="tableList"></div>
    </aside>

    <main class="main">
      <section class="panel header">
        <div class="header-left">
          <h1>Duplexer Sport SQL Explorer</h1>
        </div>
        <div class="header-actions">
          <span class="version-badge" id="appVersion"></span>
          <button class="ghost" id="whatsNewBtn">What's New</button>
        </div>
      </section>

      <section class="panel query-box">
        <div class="toolbar">
          <button class="primary" id="runQuery">Run Query</button>
          <button class="ghost" id="browseSelected">Browse Selected Table</button>
          <button class="ghost" id="clearResult">Clear Result</button>
        </div>
        <div class="sql-editor-wrap">
          <textarea id="sqlInput" spellcheck="false"></textarea>
          <div id="sqlAutocomplete" class="sql-autocomplete"></div>
        </div>
      </section>

      <section class="status panel" id="status">Initializing SQL engine...</section>

      <section class="panel view-panel">
        <div class="view-tabs">
          <button class="view-tab active" id="tabResults" type="button">Results</button>
          <button class="view-tab" id="tabSchema" type="button">Visualization</button>
        </div>
        <div class="view-meta muted" id="resultMeta">No query executed yet.</div>
        <div class="view-body">
          <div class="view-pane active" id="resultsPane">
            <section class="result-wrap" id="resultWrap"></section>
          </div>
          <div class="view-pane" id="schemaPane">
            <section class="schema-wrap">
              <svg id="schemaSvg" viewBox="0 0 1200 680" preserveAspectRatio="xMidYMid meet"></svg>
            </section>
          </div>
        </div>
      </section>
    </main>
  </div>
  <div id="colMenu" class="col-menu-pop"></div>
  <div id="whatsNewModal" class="modal-backdrop" aria-hidden="true">
    <div class="modal-card" role="dialog" aria-modal="true" aria-labelledby="whatsNewTitle">
      <div class="modal-head">
        <h3 id="whatsNewTitle">What's New</h3>
        <button type="button" class="modal-close" id="closeWhatsNew" aria-label="Close">&times;</button>
      </div>
      <div class="modal-body" id="releaseNotes"></div>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.10.3/sql-wasm.js"></script>
  <script>
    let db = null;
    let tables = [];
    let tableColumns = {};
    let allColumns = [];
    let selectedTable = null;
    let autocompleteItems = [];
    let autocompleteActiveIndex = -1;
    let resultState = { columns: [], rawValues: [], sortIndex: -1, sortDir: 'asc', valueFilters: {} };
    let menuState = null;
    const APP_VERSION = "v1.11.0";
    const SEEN_VERSION_KEY = "duplexer_sql_explorer_seen_version";
    const RELEASE_NOTES = [
      {
        version: "v1.11.0",
        date: "2026-02-24",
        notes: [
          "Hardened Arabic data quality with strict canonical indicator-name mapping and stronger AR validation rules.",
          "Removed synthetic placeholder patterns from controlled business text columns and tightened quality gates.",
          "Stabilized app initialization and loading via external dataset flow with resilient fetch handling."
        ]
      },
      {
        version: "v1.10.0",
        date: "2026-02-24",
        notes: [
          "Canonicalized schema table naming to match Schema.csv (including long MOF fact table names).",
          "Added strict generation coverage gates for full table/column reconciliation against Schema.csv.",
          "Added full data-presence and sanity sweep checks with fail-fast validation reporting.",
          "Synced regenerated seed SQL in-app to ensure consistent first-load initialization."
        ]
      },      {
        version: "v1.9.0",
        date: "2026-02-23",
        notes: [
          "Added interchangeable Results/Visualization tabs to maximize workspace.",
          "Fixed autocomplete interfering with adding new lines in SQL editor. Use Enter to add new lines. Use Tab to add the first suggestion.",
          "Autocomplete now appends one space automatically after inserted suggestion.",
          "Added robust SQL seed loading with progress and full post-load row-count verification."
        ]
      },
      {
        version: "v1.8.0",
        date: "2026-02-23",
        notes: [
          "Added global app version badge in the header.",
          "Added 'What's New' modal with centralized release notes.",
          "Release notes are now managed from a single JavaScript source."
        ]
      },
      {
        version: "v1.7.0",
        date: "2026-02-22",
        notes: [
          "Enforced cross-table ID consistency for key descriptive fields.",
          "Ensured DATE_ID-driven YEAR and SURVEY_YEAR alignment."
        ]
      }
    ];

    const SQL_KEYWORDS = [
      "SELECT", "FROM", "WHERE", "JOIN", "LEFT JOIN", "RIGHT JOIN", "INNER JOIN", "ON",
      "GROUP BY", "ORDER BY", "LIMIT", "HAVING", "DISTINCT", "AS", "WITH", "UNION", "UNION ALL",
      "AND", "OR", "NOT", "IN", "BETWEEN", "LIKE", "IS NULL", "IS NOT NULL", "CASE WHEN THEN ELSE END"
    ];
    const SQL_FUNCTIONS = [
      "COUNT()", "SUM()", "AVG()", "MIN()", "MAX()", "ROUND()",
      "COALESCE()", "NULLIF()", "CAST()", "LENGTH()", "SUBSTR()",
      "LAG() OVER ()", "LEAD() OVER ()", "ROW_NUMBER() OVER ()",
      "RANK() OVER ()", "DENSE_RANK() OVER ()"
    ];

    const statusEl = document.getElementById('status');
    const tableListEl = document.getElementById('tableList');
    const statsEl = document.getElementById('stats');
    const resultWrapEl = document.getElementById('resultWrap');
    const resultMetaEl = document.getElementById('resultMeta');
    const resultsPaneEl = document.getElementById('resultsPane');
    const schemaPaneEl = document.getElementById('schemaPane');
    const tabResultsEl = document.getElementById('tabResults');
    const tabSchemaEl = document.getElementById('tabSchema');
    const sqlInputEl = document.getElementById('sqlInput');
    const tableSearchEl = document.getElementById('tableSearch');
    const columnSearchEl = document.getElementById('columnSearch');
    const schemaSvg = document.getElementById('schemaSvg');
    const autocompleteEl = document.getElementById('sqlAutocomplete');
    const colMenuEl = document.getElementById('colMenu');
    const appVersionEl = document.getElementById('appVersion');
    const whatsNewBtn = document.getElementById('whatsNewBtn');
    const whatsNewModalEl = document.getElementById('whatsNewModal');
    const closeWhatsNewEl = document.getElementById('closeWhatsNew');
    const releaseNotesEl = document.getElementById('releaseNotes');
    let activeView = 'results';

    function setStatus(msg, isError = false) {
      statusEl.textContent = msg;
      statusEl.classList.toggle('error', isError);
    }

    function setActiveView(view) {
      activeView = view === 'schema' ? 'schema' : 'results';
      const showSchema = activeView === 'schema';
      resultsPaneEl.classList.toggle('active', !showSchema);
      schemaPaneEl.classList.toggle('active', showSchema);
      tabResultsEl.classList.toggle('active', !showSchema);
      tabSchemaEl.classList.toggle('active', showSchema);
    }

    function renderReleaseNotes() {
      appVersionEl.textContent = APP_VERSION;
      releaseNotesEl.innerHTML = RELEASE_NOTES.map(rel => {
        const notesHtml = (rel.notes || []).map(n => `<li>${escapeHtml(String(n))}</li>`).join("");
        return `
          <section class="release-item">
            <div class="release-head">
              <span class="release-version">${escapeHtml(rel.version || "")}</span>
              <span class="release-date">${escapeHtml(rel.date || "")}</span>
            </div>
            <ul>${notesHtml}</ul>
          </section>
        `;
      }).join("");
    }

    function openWhatsNew() {
      whatsNewModalEl.classList.add('show');
      whatsNewModalEl.setAttribute('aria-hidden', 'false');
    }

    function closeWhatsNew() {
      whatsNewModalEl.classList.remove('show');
      whatsNewModalEl.setAttribute('aria-hidden', 'true');
    }

    function openWhatsNewIfFirstTimeForVersion() {
      try {
        const seenVersion = localStorage.getItem(SEEN_VERSION_KEY);
        if (seenVersion !== APP_VERSION) {
          openWhatsNew();
          localStorage.setItem(SEEN_VERSION_KEY, APP_VERSION);
        }
      } catch (_) {
        // Ignore storage errors (private mode / blocked storage).
      }
    }

    function normalizeDumpSql(rawSql) {
      let s = rawSql.replace(/\r/g, '');
      s = s.replace(/^\s*SET\s+.*?;\s*$/gmi, '');
      s = s.replace(/^\s*CREATE\s+DATABASE\s+.*?;\s*$/gmi, '');
      s = s.replace(/^\s*USE\s+.*?;\s*$/gmi, '');
      s = s.replace(/^\s*COMMIT\s*;\s*$/gmi, '');
      s = s.replace(/CREATE TABLE IF NOT EXISTS\s+`([^`]+)`/g, 'CREATE TABLE IF NOT EXISTS gold.`$1`');
      s = s.replace(/INSERT INTO\s+`([^`]+)`/g, 'INSERT INTO gold.`$1`');
      return s;
    }

    function splitSqlStatements(sql) {
      const out = [];
      let start = 0;
      let inStr = false;
      for (let i = 0; i < sql.length; i++) {
        const ch = sql[i];
        if (ch === "'") {
          if (inStr && i + 1 < sql.length && sql[i + 1] === "'") {
            i++;
            continue;
          }
          inStr = !inStr;
          continue;
        }
        if (!inStr && ch === ';') {
          const stmt = sql.slice(start, i).trim();
          if (stmt) out.push(stmt);
          start = i + 1;
        }
      }
      const tail = sql.slice(start).trim();
      if (tail) out.push(tail);
      return out;
    }

    function splitInsertIntoBatches(stmt, batchSize = 25) {
      const m = stmt.match(/^(INSERT\s+INTO[\s\S]+?\bVALUES)\s*([\s\S]+)$/i);
      if (!m) return [stmt];
      const prefix = m[1];
      const valuesPart = m[2].trim();
      const tuples = [];
      let inStr = false;
      let depth = 0;
      let start = -1;
      for (let i = 0; i < valuesPart.length; i++) {
        const ch = valuesPart[i];
        if (ch === "'") {
          if (inStr && i + 1 < valuesPart.length && valuesPart[i + 1] === "'") {
            i++;
            continue;
          }
          inStr = !inStr;
          continue;
        }
        if (inStr) continue;
        if (ch === '(') {
          if (depth === 0) start = i;
          depth++;
          continue;
        }
        if (ch === ')') {
          depth--;
          if (depth === 0 && start >= 0) {
            tuples.push(valuesPart.slice(start, i + 1).trim());
            start = -1;
          }
        }
      }
      if (!tuples.length) return [stmt];
      const parts = [];
      for (let i = 0; i < tuples.length; i += batchSize) {
        const batch = tuples.slice(i, i + batchSize).join(',\n  ');
        parts.push(`${prefix}\n  ${batch}`);
      }
      return parts;
    }

    function extractInsertTableName(stmt) {
      const m = stmt.match(/^INSERT\s+INTO\s+(?:gold\.)?`([^`]+)`/i);
      return m ? m[1] : null;
    }

    function countInsertTuples(stmt) {
      const m = stmt.match(/^(INSERT\s+INTO[\s\S]+?\bVALUES)\s*([\s\S]+)$/i);
      if (!m) return 0;
      const valuesPart = m[2].trim();
      let tuples = 0;
      let inStr = false;
      let depth = 0;
      for (let i = 0; i < valuesPart.length; i++) {
        const ch = valuesPart[i];
        if (ch === "'") {
          if (inStr && i + 1 < valuesPart.length && valuesPart[i + 1] === "'") {
            i++;
            continue;
          }
          inStr = !inStr;
          continue;
        }
        if (inStr) continue;
        if (ch === '(' && depth === 0) tuples++;
        if (ch === '(') depth++;
        if (ch === ')') depth--;
      }
      return tuples;
    }

    async function execDumpSqlRobust(rawSql, onProgress = null) {
      const normalized = normalizeDumpSql(rawSql);
      const statements = splitSqlStatements(normalized);
      const expectedByTable = {};
      let expectedRows = 0;
      let totalBatches = 0;
      let executedBatches = 0;

      for (const stmt of statements) {
        if (!/^INSERT\s+INTO\b/i.test(stmt)) continue;
        const table = extractInsertTableName(stmt);
        const tupleCount = countInsertTuples(stmt);
        if (table) expectedByTable[table] = (expectedByTable[table] || 0) + tupleCount;
        expectedRows += tupleCount;
        totalBatches += Math.max(1, splitInsertIntoBatches(stmt, 25).length);
      }

      let loadedRows = 0;
      for (const stmt of statements) {
        if (/^INSERT\s+INTO\b/i.test(stmt)) {
          const table = extractInsertTableName(stmt);
          const batches = splitInsertIntoBatches(stmt, 25);
          for (const b of batches) {
            db.exec(b);
            loadedRows += countInsertTuples(b);
            executedBatches++;
            if (onProgress) {
              onProgress({
                phase: "loading",
                loadedRows,
                expectedRows,
                executedBatches,
                totalBatches,
                table
              });
            }
            if (executedBatches % 8 === 0) {
              await new Promise(resolve => setTimeout(resolve, 0));
            }
          }
        } else {
          db.exec(stmt);
        }
      }

      const mismatches = [];
      for (const [table, expected] of Object.entries(expectedByTable)) {
        const q = `SELECT COUNT(*) FROM gold.\`${table}\``;
        const res = db.exec(q);
        const actual = Number(res?.[0]?.values?.[0]?.[0] ?? 0);
        if (actual !== expected) mismatches.push(`${table}: expected ${expected}, loaded ${actual}`);
      }
      if (mismatches.length) {
        throw new Error(`Data load verification failed (${mismatches.length} tables): ${mismatches.slice(0, 5).join(' | ')}`);
      }

      if (onProgress) {
        onProgress({
          phase: "verified",
          loadedRows: expectedRows,
          expectedRows,
          executedBatches: totalBatches,
          totalBatches
        });
      }
    }

    function normalizeQuery(q) {
      let s = q.trim();
      s = s.replace(/\r/g, '');
      s = s.replace(/`gold`\./gi, '');
      s = s.replace(/\bgold\./gi, '');
      return s;
    }

    function isReadOnlyQuery(q) {
      const s = q.trim().replace(/;\s*$/, '');
      if (!/^(select|with|pragma)\b/i.test(s)) return false;
      if (/;\s*\S+/m.test(s)) return false;
      const forbidden = /\b(insert|update|delete|create|drop|alter|replace|truncate|attach|detach|vacuum|begin|commit|rollback|grant|revoke)\b/i;
      return !forbidden.test(s);
    }

    function getSingleResult(sql) {
      const rows = db.exec(sql);
      return rows && rows.length ? rows[0] : { columns: [], values: [] };
    }

    function resetResultScroll() {
      resultWrapEl.scrollTop = 0;
      resultWrapEl.scrollLeft = 0;
    }

    function renderResult(columns, values, opts = {}) {
      const shouldResetScroll = !!opts.resetScroll;
      if (!columns.length) {
        resultWrapEl.innerHTML = '<div class="muted" style="padding:10px;">No rows returned.</div>';
        if (shouldResetScroll) resetResultScroll();
        closeColumnMenu();
        return;
      }
      const previousColumns = resultState.columns.slice();
      const columnsChanged = previousColumns.length !== columns.length || previousColumns.some((c, i) => c !== columns[i]);
      if (columnsChanged) {
        resultState.sortIndex = -1;
        resultState.sortDir = 'asc';
        resultState.valueFilters = {};
      }
      resultState.columns = columns.slice();
      resultState.rawValues = values.slice();
      if (resultState.sortIndex >= columns.length) resultState.sortIndex = -1;

      const filtered = resultState.rawValues.filter(row => {
        for (let i = 0; i < resultState.columns.length; i++) {
          const allowed = resultState.valueFilters[i];
          if (!allowed) continue;
          if (!allowed.has(valueKey(row[i]))) return false;
        }
        return true;
      });

      const rows = filtered.slice();
      if (resultState.sortIndex >= 0) {
        const idx = resultState.sortIndex;
        const dir = resultState.sortDir === 'desc' ? -1 : 1;
        rows.sort((a, b) => {
          const av = a[idx];
          const bv = b[idx];
          if (av == null && bv == null) return 0;
          if (av == null) return -1 * dir;
          if (bv == null) return 1 * dir;
          const an = Number(av);
          const bn = Number(bv);
          const aNum = Number.isFinite(an);
          const bNum = Number.isFinite(bn);
          if (aNum && bNum) return (an - bn) * dir;
          return String(av).localeCompare(String(bv), undefined, { numeric: true, sensitivity: 'base' }) * dir;
        });
      }

      let html = '<table><thead><tr>' + resultState.columns.map((c, i) => {
        const isSorted = resultState.sortIndex === i;
        const arrow = isSorted ? (resultState.sortDir === 'asc' ? ' ▲' : ' ▼') : '';
        const filterActive = !!resultState.valueFilters[i];
        return `<th title="${escapeHtml(c)}"><span class="th-inner">${escapeHtml(c)}${arrow}<button class="col-menu-btn ${filterActive ? 'active' : ''}" data-col-idx="${i}" aria-label="Column menu">&#9662;</button></span></th>`;
      }).join('') + '</tr>';
      html += '</thead><tbody>';
      for (const row of rows) {
        html += '<tr>' + row.map(v => `<td>${escapeHtml(v == null ? 'NULL' : String(v))}</td>`).join('') + '</tr>';
      }
      html += '</tbody></table>';
      resultWrapEl.innerHTML = html;
      if (shouldResetScroll) resetResultScroll();

      resultWrapEl.querySelectorAll('button.col-menu-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          const idx = Number(btn.getAttribute('data-col-idx'));
          openColumnMenu(idx, btn);
        });
      });
    }

    function valueKey(v) {
      if (v == null) return '__BLANK__';
      const s = String(v);
      return s.length ? s : '__BLANK__';
    }

    function valueLabelFromKey(k) {
      return k === '__BLANK__' ? '(Blanks)' : k;
    }

    function getColumnUniqueKeys(colIdx) {
      const set = new Set();
      for (const row of resultState.rawValues) set.add(valueKey(row[colIdx]));
      return Array.from(set).sort((a, b) => valueLabelFromKey(a).localeCompare(valueLabelFromKey(b), undefined, { numeric: true, sensitivity: 'base' }));
    }

    function closeColumnMenu() {
      menuState = null;
      colMenuEl.classList.remove('show');
      colMenuEl.innerHTML = '';
    }

    function renderColumnMenu() {
      if (!menuState) return;
      const all = menuState.allKeys;
      const q = menuState.search.toLowerCase();
      const visible = all.filter(k => valueLabelFromKey(k).toLowerCase().includes(q));
      const htmlVals = visible.map(k => {
        const checked = menuState.tempSelected.has(k) ? 'checked' : '';
        return `<label class="menu-val-item"><input type="checkbox" data-val-key="${escapeHtml(k)}" ${checked} /><span>${escapeHtml(valueLabelFromKey(k))}</span></label>`;
      }).join('') || '<div class="menu-val-item">No values</div>';

      colMenuEl.innerHTML = `
        <div class="col-menu-head">
          <button class="col-menu-action" data-action="sort-asc">Sort A to Z</button>
          <button class="col-menu-action" data-action="sort-desc">Sort Z to A</button>
        </div>
        <div class="col-menu-body">
          <div class="menu-title">Filter by values</div>
          <div class="menu-links"><a data-action="select-all">Select all</a> - <a data-action="clear-all">Clear</a></div>
          <input class="menu-search" id="menuSearch" type="text" placeholder="Search values..." value="${escapeHtml(menuState.search)}" />
          <div class="menu-values">${htmlVals}</div>
        </div>
        <div class="menu-footer">
          <button class="cancel" data-action="cancel">Cancel</button>
          <button class="ok" data-action="ok">OK</button>
        </div>
      `;
      colMenuEl.classList.add('show');

      colMenuEl.querySelectorAll('[data-action]').forEach(el => {
        el.addEventListener('click', (e) => {
          const action = el.getAttribute('data-action');
          if (action === 'sort-asc') {
            resultState.sortIndex = menuState.colIdx;
            resultState.sortDir = 'asc';
            renderResult(resultState.columns, resultState.rawValues);
            closeColumnMenu();
            return;
          }
          if (action === 'sort-desc') {
            resultState.sortIndex = menuState.colIdx;
            resultState.sortDir = 'desc';
            renderResult(resultState.columns, resultState.rawValues);
            closeColumnMenu();
            return;
          }
          if (action === 'select-all') {
            menuState.tempSelected = new Set(menuState.allKeys);
            renderColumnMenu();
            return;
          }
          if (action === 'clear-all') {
            menuState.tempSelected = new Set();
            renderColumnMenu();
            return;
          }
          if (action === 'cancel') {
            closeColumnMenu();
            return;
          }
          if (action === 'ok') {
            if (menuState.tempSelected.size === menuState.allKeys.length) {
              resultState.valueFilters[menuState.colIdx] = null;
            } else {
              resultState.valueFilters[menuState.colIdx] = new Set(menuState.tempSelected);
            }
            renderResult(resultState.columns, resultState.rawValues);
            closeColumnMenu();
          }
        });
      });

      const searchEl = colMenuEl.querySelector('#menuSearch');
      if (searchEl) {
        searchEl.addEventListener('input', () => {
          menuState.search = searchEl.value || '';
          renderColumnMenu();
        });
      }

      colMenuEl.querySelectorAll('input[type="checkbox"][data-val-key]').forEach(chk => {
        chk.addEventListener('change', () => {
          const key = chk.getAttribute('data-val-key');
          if (chk.checked) menuState.tempSelected.add(key);
          else menuState.tempSelected.delete(key);
        });
      });
    }

    function openColumnMenu(colIdx, anchorEl) {
      const allKeys = getColumnUniqueKeys(colIdx);
      const current = resultState.valueFilters[colIdx];
      menuState = {
        colIdx,
        allKeys,
        tempSelected: current ? new Set(current) : new Set(allKeys),
        search: ''
      };
      const rect = anchorEl.getBoundingClientRect();
      const menuWidth = 250;
      let left = rect.left;
      if (left + menuWidth > window.innerWidth - 10) left = window.innerWidth - menuWidth - 10;
      let top = rect.bottom + 6;
      if (top + 420 > window.innerHeight - 10) top = Math.max(10, rect.top - 420);
      colMenuEl.style.left = `${left}px`;
      colMenuEl.style.top = `${top}px`;
      renderColumnMenu();
    }

    function escapeHtml(s) {
      return s
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');
    }

    function refreshColumnIndex() {
      const set = new Set();
      for (const t of tables) {
        for (const c of (tableColumns[t] || [])) set.add(c);
      }
      allColumns = Array.from(set).sort((a, b) => a.localeCompare(b));
    }

    function quoteIdentifier(name) {
      return /^[A-Za-z_][A-Za-z0-9_]*$/.test(name) ? name : `\`${name}\``;
    }

    function getTokenAtCursor(text, cursorPos) {
      let start = cursorPos;
      let end = cursorPos;
      while (start > 0 && /[A-Za-z0-9_`.]/.test(text[start - 1])) start--;
      while (end < text.length && /[A-Za-z0-9_`.]/.test(text[end])) end++;
      return { start, end, token: text.slice(start, end), before: text.slice(0, start) };
    }

    function parseAliasMap(sqlPrefix) {
      const map = {};
      const re = /\b(?:from|join)\s+([`A-Za-z0-9_.]+)(?:\s+(?:as\s+)?([A-Za-z_][A-Za-z0-9_]*))?/gi;
      let m;
      while ((m = re.exec(sqlPrefix)) !== null) {
        const raw = m[1].replace(/`/g, '');
        const table = raw.split('.').pop();
        if (!table) continue;
        map[table.toLowerCase()] = table;
        if (m[2]) map[m[2].toLowerCase()] = table;
      }
      return map;
    }

    function stripSqlComments(sql) {
      return sql
        .replace(/\/\*[\s\S]*?\*\//g, ' ')
        .replace(/--[^\n\r]*/g, ' ');
    }

    function parseFromTablesInOrder(sql) {
      const out = [];
      const re = /\b(?:from|join)\s+([`A-Za-z0-9_.]+)/gi;
      let m;
      while ((m = re.exec(sql)) !== null) {
        const raw = (m[1] || '').replace(/`/g, '');
        const table = raw.split('.').pop();
        if (table) out.push(table);
      }
      return out;
    }

    function extractFirstSelectExpression(sql) {
      const cleaned = stripSqlComments(sql);
      const m = cleaned.match(/\bselect\b\s+([\s\S]+?)\s+\bfrom\b/i);
      if (!m) return '';
      let s = m[1].trim();
      s = s.replace(/^\s*distinct\s+/i, '');

      let depth = 0;
      let quote = null;
      for (let i = 0; i < s.length; i++) {
        const ch = s[i];
        if (quote) {
          if (ch === quote) quote = null;
          continue;
        }
        if (ch === "'" || ch === '"' || ch === '`') {
          quote = ch;
          continue;
        }
        if (ch === '(') depth++;
        else if (ch === ')' && depth > 0) depth--;
        else if (ch === ',' && depth === 0) return s.slice(0, i).trim();
      }
      return s.trim();
    }

    function hasColumn(tableName, colName) {
      const cols = tableColumns[tableName] || [];
      const needle = String(colName || '').toLowerCase();
      return cols.some(c => String(c).toLowerCase() === needle);
    }

    function inferTableFromQuery(sql) {
      const cleaned = stripSqlComments(sql);
      const firstExpr = extractFirstSelectExpression(cleaned);
      const aliasMap = parseAliasMap(cleaned);
      const fromTables = parseFromTablesInOrder(cleaned);
      if (!firstExpr) return fromTables[0] || null;

      const exprNoSpace = firstExpr.replace(/\s+/g, '');
      if (exprNoSpace === '*') return fromTables[0] || null;
      const starMatch = firstExpr.match(/^`?([A-Za-z_][A-Za-z0-9_]*)`?\s*\.\s*\*$/);
      if (starMatch) {
        const left = starMatch[1];
        const resolved = aliasMap[left.toLowerCase()] || left;
        if (tables.includes(resolved)) return resolved;
        return fromTables[0] || null;
      }

      const qualified = firstExpr.match(/`?([A-Za-z_][A-Za-z0-9_]*)`?\s*\.\s*`([^`]+)`|`?([A-Za-z_][A-Za-z0-9_]*)`?\s*\.\s*([A-Za-z_][A-Za-z0-9_\/&$-]*)/);
      if (qualified) {
        const left = (qualified[1] || qualified[3] || '').replace(/`/g, '');
        const col = (qualified[2] || qualified[4] || '').replace(/`/g, '');
        const resolved = aliasMap[left.toLowerCase()] || left;
        if (tables.includes(resolved) && hasColumn(resolved, col)) return resolved;
      }

      const bt = firstExpr.match(/`([^`]+)`/);
      let firstCol = bt ? bt[1] : null;
      if (!firstCol) {
        const tokens = firstExpr.match(/[A-Za-z_][A-Za-z0-9_\/&$-]*/g) || [];
        const deny = new Set(
          [
            ...SQL_KEYWORDS.flatMap(k => k.toLowerCase().split(/\s+/)),
            ...SQL_FUNCTIONS.map(f => f.toLowerCase().replace(/\(.*/, '')),
            'over', 'partition', 'by', 'asc', 'desc', 'null', 'case', 'when', 'then', 'else', 'end'
          ]
        );
        firstCol = tokens.find(t => !deny.has(t.toLowerCase())) || null;
      }
      if (!firstCol) return null;

      for (const t of fromTables) {
        if (hasColumn(t, firstCol)) return t;
      }
      const matches = tables.filter(t => hasColumn(t, firstCol));
      if (matches.length === 1) return matches[0];
      if (matches.length > 1) {
        const dim = matches.find(t => /^dim_/i.test(t));
        return dim || matches[0];
      }
      return fromTables[0] || null;
    }

    function addCandidate(list, seen, label, insertText, kind) {
      const key = insertText.toLowerCase();
      if (seen.has(key)) return;
      seen.add(key);
      list.push({ label, insertText, kind });
    }

    function buildAutocompleteSuggestions() {
      const value = sqlInputEl.value;
      const cursorPos = sqlInputEl.selectionStart;
      const info = getTokenAtCursor(value, cursorPos);
      const tokenLower = info.token.toLowerCase();
      const out = [];
      const seen = new Set();
      const before = value.slice(0, cursorPos);
      const aliasMap = parseAliasMap(before);
      const prevWord = (info.before.match(/([A-Za-z_]+)\s*$/) || [null, ""])[1].toLowerCase();
      const expectTable = /^(from|join)$/.test(prevWord);

      if (info.token.includes(".")) {
        const parts = info.token.split(".");
        const leftRaw = (parts[0] || "").replace(/`/g, "");
        const rightRaw = (parts[1] || "").replace(/`/g, "");
        const rightLower = rightRaw.toLowerCase();

        if (leftRaw.toLowerCase() === "gold") {
          for (const t of tables) {
            if (!t.toLowerCase().includes(rightLower)) continue;
            addCandidate(out, seen, `gold.${t}`, `gold.${quoteIdentifier(t)}`, "table");
          }
        } else {
          const resolvedTable = aliasMap[leftRaw.toLowerCase()] || leftRaw;
          const cols = tableColumns[resolvedTable] || [];
          for (const c of cols) {
            if (!c.toLowerCase().includes(rightLower)) continue;
            addCandidate(out, seen, `${leftRaw}.${c}`, `${parts[0]}.${quoteIdentifier(c)}`, "column");
          }
        }
      } else {
        if (!expectTable) {
          for (const kw of SQL_KEYWORDS) {
            if (!kw.toLowerCase().includes(tokenLower)) continue;
            addCandidate(out, seen, kw, kw, "keyword");
          }
          for (const fn of SQL_FUNCTIONS) {
            if (!fn.toLowerCase().includes(tokenLower)) continue;
            addCandidate(out, seen, fn, fn, "function");
          }
          for (const c of allColumns) {
            if (!c.toLowerCase().includes(tokenLower)) continue;
            addCandidate(out, seen, c, quoteIdentifier(c), "column");
            if (out.length >= 24) break;
          }
        }
        for (const t of tables) {
          if (!t.toLowerCase().includes(tokenLower)) continue;
          addCandidate(out, seen, `gold.${t}`, `gold.${quoteIdentifier(t)}`, "table");
          addCandidate(out, seen, t, quoteIdentifier(t), "table");
        }
      }

      const starts = out.filter(x => x.label.toLowerCase().startsWith(tokenLower));
      const contains = out.filter(x => !x.label.toLowerCase().startsWith(tokenLower));
      return starts.concat(contains).slice(0, 14);
    }

    function renderAutocomplete(items) {
      autocompleteItems = items;
      autocompleteActiveIndex = items.length ? 0 : -1;
      if (!items.length) {
        autocompleteEl.classList.remove("show");
        autocompleteEl.innerHTML = "";
        return;
      }
      autocompleteEl.innerHTML = items.map((item, idx) => (
        `<button type="button" class="sql-suggest ${idx === autocompleteActiveIndex ? "active" : ""}" data-idx="${idx}">
          ${escapeHtml(item.label)}<span class="kind">${escapeHtml(item.kind)}</span>
        </button>`
      )).join("");
      autocompleteEl.classList.add("show");
    }

    function setAutocompleteActive(idx) {
      if (!autocompleteItems.length) return;
      autocompleteActiveIndex = (idx + autocompleteItems.length) % autocompleteItems.length;
      [...autocompleteEl.querySelectorAll(".sql-suggest")].forEach((el, i) => {
        el.classList.toggle("active", i === autocompleteActiveIndex);
      });
    }

    function hideAutocomplete() {
      autocompleteItems = [];
      autocompleteActiveIndex = -1;
      autocompleteEl.classList.remove("show");
      autocompleteEl.innerHTML = "";
    }

    function applyAutocomplete(item) {
      const pos = sqlInputEl.selectionStart;
      const info = getTokenAtCursor(sqlInputEl.value, pos);
      const before = sqlInputEl.value.slice(0, info.start);
      const after = sqlInputEl.value.slice(info.end);
      const insert = `${item.insertText} `;
      sqlInputEl.value = before + insert + after;
      const newPos = before.length + insert.length;
      sqlInputEl.focus();
      sqlInputEl.setSelectionRange(newPos, newPos);
      hideAutocomplete();
    }

    function triggerAutocomplete() {
      const info = getTokenAtCursor(sqlInputEl.value, sqlInputEl.selectionStart);
      if (!info.token && !/[A-Za-z_]/.test((info.before.match(/([A-Za-z_]+)\s*$/) || [null, ""])[1] || "")) {
        hideAutocomplete();
        return;
      }
      renderAutocomplete(buildAutocompleteSuggestions());
    }

    function getFilteredTables() {
      const tableKey = tableSearchEl.value.trim().toLowerCase();
      const columnKey = columnSearchEl.value.trim().toLowerCase();
      return tables.filter(t => {
        const tableMatch = !tableKey || t.toLowerCase().includes(tableKey);
        const colMatch = !columnKey || (tableColumns[t] || []).some(c => c.toLowerCase().includes(columnKey));
        return tableMatch && colMatch;
      });
    }

    function listTables() {
      const res = db.exec("SELECT name FROM sqlite_master WHERE type='table' ORDER BY name");
      tables = res[0]?.values?.map(v => v[0]) || [];
      selectedTable = selectedTable || tables[0] || null;
      tableColumns = parseSchemaColumns();
      refreshColumnIndex();
      renderTableList();
      statsEl.innerHTML = `<div><strong>Schema:</strong> gold</div><div><strong>Tables:</strong> ${tables.length}</div><div><strong>Mode:</strong> Read-only SELECT</div>`;
    }

    function renderTableList() {
      const filtered = getFilteredTables();
      const prevScrollTop = tableListEl.scrollTop;
      tableListEl.innerHTML = '';
      for (const name of filtered) {
        const b = document.createElement('button');
        b.className = 'table-btn' + (name === selectedTable ? ' active' : '');
        b.textContent = name;
        b.title = name;
        b.onclick = () => {
          selectedTable = name;
          renderTableList();
          browseTable(name);
          drawSchema();
        };
        tableListEl.appendChild(b);
      }
      if (!filtered.length) {
        tableListEl.innerHTML = '<div class="muted" style="padding: 10px 14px;">No table matches.</div>';
      } else {
        tableListEl.scrollTop = prevScrollTop;
      }
    }

    function browseTable(name) {
      try {
        const countRes = getSingleResult(`SELECT COUNT(*) AS n FROM \`${name}\``);
        const count = countRes.values[0]?.[0] ?? 0;
        const result = getSingleResult(`SELECT * FROM \`${name}\` LIMIT 200`);
        renderResult(result.columns, result.values, { resetScroll: true });
        resultMetaEl.textContent = `Browsing gold.${name} | rows: ${count} | showing up to 200`;
        setStatus(`Loaded table gold.${name}`);
      } catch (err) {
        setStatus(`Browse failed: ${err.message}`, true);
      }
    }

    function parseSchemaColumns() {
      const byTable = {};
      for (const t of tables) {
        const res = db.exec(`PRAGMA table_info(\`${t}\`)`);
        const cols = (res[0]?.values || []).map(v => v[1]);
        byTable[t] = cols;
      }
      return byTable;
    }

    function inferEdges(colMap) {
      const edges = [];
      const tableSet = new Set(tables);
      for (const src of tables) {
        for (const col of colMap[src]) {
          if (!/_ID$/i.test(col)) continue;
          if (/^(GLD_|SLVR_|BRNZ_)/i.test(col)) continue;
          const candidates = [];
          for (const dst of tables) {
            if (dst === src) continue;
            if (!colMap[dst].includes(col)) continue;
            let score = 0;
            if (/^dim_/i.test(dst)) score += 3;
            if (/^dim_/i.test(src)) score -= 2;
            if (dst.toLowerCase().includes(col.replace(/_ID$/i, '').toLowerCase())) score += 2;
            if (/^fact_/i.test(src) || /_fact_/i.test(src)) score += 1;
            candidates.push({ dst, score });
          }
          candidates.sort((a, b) => b.score - a.score);
          if (candidates.length && candidates[0].score >= 2 && tableSet.has(candidates[0].dst)) {
            edges.push({ src, dst: candidates[0].dst, col });
          }
        }
      }
      const uniq = new Set();
      return edges.filter(e => {
        const key = `${e.src}|${e.dst}|${e.col}`;
        if (uniq.has(key)) return false;
        uniq.add(key);
        return true;
      });
    }

    function drawSchema() {
      const colMap = tableColumns;
      const allEdges = inferEdges(colMap);
      const focus = selectedTable || tables[0];
      if (!focus) return;
      const focusEdges = allEdges.filter(e => e.src === focus || e.dst === focus);
      const linkMap = new Map();
      for (const e of focusEdges) {
        const neighbor = e.src === focus ? e.dst : e.src;
        if (!linkMap.has(neighbor)) linkMap.set(neighbor, []);
        linkMap.get(neighbor).push(e.col);
      }
      const neighborsAll = Array.from(linkMap.keys());

      const neighborScore = new Map();
      for (const n of neighborsAll) {
        let score = 0;
        if (/^dim_/i.test(n)) score += 3;
        if (/_fact_/i.test(n) || /^fact_/i.test(n)) score += 2;
        score += (linkMap.get(n) || []).length;
        neighborScore.set(n, score);
      }
      const neighbors = neighborsAll
        .slice()
        .sort((a, b) => (neighborScore.get(b) - neighborScore.get(a)) || a.localeCompare(b));

      const w = 1200;
      const h = 680;

      const pos = {};
      const cx = w / 2;
      const cy = h / 2;
      pos[focus] = { x: cx, y: cy };

      function estimateNodeWidth(name, isFocus) {
        const len = String(name || '').length;
        const base = isFocus ? 164 : 146;
        const perChar = isFocus ? 6.9 : 6.4;
        const maxW = isFocus ? 340 : 300;
        return Math.min(maxW, Math.max(base, Math.round(base + len * perChar)));
      }

      const nodeWidth = {};
      nodeWidth[focus] = estimateNodeWidth(focus, true);
      neighbors.forEach(n => {
        nodeWidth[n] = estimateNodeWidth(n, false);
      });

      // Adaptive elliptical rings: prevents node overlap for low and high connection counts.
      const focusHalfW = Math.ceil(nodeWidth[focus] / 2);
      const maxNeighborHalfW = Math.max(72, ...neighbors.map(n => Math.ceil(nodeWidth[n] / 2)));
      const minNodeGap = 26;
      const maxRx = Math.min(w * 0.45, 520);
      const maxRy = Math.min(h * 0.40, 260);
      const baseRx = Math.max(260, focusHalfW + maxNeighborHalfW + minNodeGap);
      const baseRy = Math.max(170, 16 + 17 + minNodeGap);
      const ringGapX = 88;
      const ringGapY = 62;

      function ellipseCircumference(rx, ry) {
        return 2 * Math.PI * Math.sqrt((rx * rx + ry * ry) / 2);
      }

      const rings = [];
      let cursor = 0;
      let ring = 0;
      while (cursor < neighbors.length) {
        const rx = Math.min(baseRx + ring * ringGapX, maxRx);
        const ry = Math.min(baseRy + ring * ringGapY, maxRy);
        const cap = Math.max(4, Math.floor(ellipseCircumference(rx, ry) / (maxNeighborHalfW * 2 + minNodeGap)));
        const items = neighbors.slice(cursor, cursor + cap);
        rings.push({ items, rx, ry });
        cursor += items.length;
        ring++;
      }

      rings.forEach((ringObj, ringIdx) => {
        const ringItems = ringObj.items;
        const rx = ringObj.rx;
        const ry = ringObj.ry;
        const ringOffset = (ringIdx % 2) * (Math.PI / Math.max(8, ringItems.length));
        ringItems.forEach((n, i) => {
          const a = (-Math.PI / 2) + ringOffset + (Math.PI * 2 * i / Math.max(1, ringItems.length));
          pos[n] = { x: cx + Math.cos(a) * rx, y: cy + Math.sin(a) * ry, angle: a, ring: ringIdx };
        });
      });

      const edgeSvg = neighbors.map(n => {
        const p2 = pos[n];
        if (!p2) return '';
        return `<line x1="${cx}" y1="${cy}" x2="${p2.x}" y2="${p2.y}" stroke="#64d9aa" stroke-width="1.7" opacity="0.92" />`;
      }).join('');

      // Label each neighbor connection once; collapse multiple keys into a compact label.
      const showEdgeLabels = neighbors.length <= 40;
      const edgeLabelSvg = showEdgeLabels ? neighbors.map((n, i) => {
        const p = pos[n];
        if (!p) return '';
        const cols = (linkMap.get(n) || []);
        const label = cols.length === 1 ? cols[0] : `${cols.length} keys`;
        const t = 0.56 + ((i % 4) - 1.5) * 0.03;
        const x = cx + (p.x - cx) * t;
        const y = cy + (p.y - cy) * t;
        const nx = -(p.y - cy);
        const ny = (p.x - cx);
        const nlen = Math.hypot(nx, ny) || 1;
        const ox = (nx / nlen) * (18 + (i % 5) * 4);
        const oy = (ny / nlen) * (18 + (i % 5) * 4);
        const rx = (p.x - cx);
        const ry = (p.y - cy);
        const rlen = Math.hypot(rx, ry) || 1;
        const rox = (rx / rlen) * 6;
        const roy = (ry / rlen) * 6;
        const lx = x + ox + rox;
        const ly = y + oy + roy;
        const textW = Math.min(180, Math.max(28, Math.round(label.length * 6.3 + 12)));
        const textH = 16;
        return `
          <g transform="translate(${lx},${ly})">
            <rect x="${-textW/2}" y="-11" width="${textW}" height="${textH}" rx="5" ry="5" fill="#0d141d" stroke="#1f3040" stroke-width="0.8" />
            <text x="0" y="1" text-anchor="middle" font-size="10" fill="#8ea0b8">${escapeHtml(label)}</text>
          </g>
        `;
      }).join('') : '';

      const nodeSvg = [focus, ...neighbors].map(n => {
        const p = pos[n];
        const isFocus = n === focus;
        const nodeFill = isFocus ? '#1c2c3a' : (/^dim_/i.test(n) ? '#14263a' : '#1a2330');
        const stroke = isFocus ? '#64d9aa' : '#3a5169';
        const wNode = nodeWidth[n] || (isFocus ? 190 : 168);
        const hNode = isFocus ? 32 : 34;
        return `
          <g transform="translate(${p.x},${p.y})">
            <rect x="${-wNode/2}" y="${-hNode/2}" rx="8" ry="8" width="${wNode}" height="${hNode}" fill="${nodeFill}" stroke="${stroke}" stroke-width="${isFocus ? 2.4 : 1.2}"></rect>
            <text text-anchor="middle" y="5" font-size="${isFocus ? 11 : 10.5}" font-family="IBM Plex Sans, Segoe UI, sans-serif" fill="#dce7f5">${escapeHtml(n)}</text>
          </g>
        `;
      }).join('');

      schemaSvg.innerHTML = `<rect x="0" y="0" width="1200" height="680" fill="#0d141d"/>${edgeSvg}${edgeLabelSvg}${nodeSvg}`;
    }

    async function init() {
      try {
        const SQL = await initSqlJs({
          locateFile: file => `https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.10.3/${file}`
        });
        const dbCandidates = [
          'gold.sqlite',
          './gold.sqlite',
          new URL('gold.sqlite', window.location.href).toString()
        ];
        let loadedDb = false;
        for (const url of dbCandidates) {
          try {
            setStatus(`Downloading prebuilt database (${url})...`);
            const resp = await fetch(url, { cache: 'no-cache' });
            if (!resp.ok) continue;
            const buf = await resp.arrayBuffer();
            setStatus('Opening database...');
            db = new SQL.Database(new Uint8Array(buf));
            loadedDb = true;
            break;
          } catch (_) {
            // try next candidate
          }
        }

        if (!loadedDb) {
          const sqlCandidates = [
            'generated_data_web.sql',
            './generated_data_web.sql',
            new URL('generated_data_web.sql', window.location.href).toString()
          ];
          for (const url of sqlCandidates) {
            try {
              setStatus(`Fallback: downloading SQL seed (${url})...`);
              const resp = await fetch(url, { cache: 'no-cache' });
              if (!resp.ok) continue;
              const raw = await resp.text();
              if (!raw.trim()) continue;
              db = new SQL.Database();
              setStatus('Loading SQL seed (fallback mode)...');
              await execDumpSqlRobust(raw);
              loadedDb = true;
              break;
            } catch (_) {
              // try next candidate
            }
          }
        }

        if (!loadedDb) {
          const hint = window.location.protocol === 'file:'
            ? "Open via a local server (not file://), or deploy with gold.sqlite next to index.html."
            : "Ensure gold.sqlite is deployed in the same folder as index.html.";
          throw new Error(`Failed to fetch dataset files. ${hint}`);
        }

        listTables();
        drawSchema();
        if (selectedTable) browseTable(selectedTable);
        sqlInputEl.value = "SELECT * FROM dim_country LIMIT 20;";

        setStatus(`Schema coverage OK | Tables: ${tables.length} | Columns: exact match | Ready. Read-only mode enabled.`);
      } catch (err) {
        setStatus(`Initialization error: ${err.message}`, true);
      }
    }

    document.getElementById('runQuery').onclick = () => {
      if (!db) return;
      setActiveView('results');
      const q = normalizeQuery(sqlInputEl.value);
      if (!isReadOnlyQuery(q)) {
        setStatus('Blocked: only single SELECT/WITH/PRAGMA read queries are allowed.', true);
        return;
      }
      const inferredTable = inferTableFromQuery(q);
      if (inferredTable && inferredTable !== selectedTable) {
        selectedTable = inferredTable;
        renderTableList();
        drawSchema();
      }
      try {
        const t0 = performance.now();
        const r = getSingleResult(q);
        const t1 = performance.now();
        renderResult(r.columns || [], r.values || [], { resetScroll: true });
        resultMetaEl.textContent = `Rows: ${(r.values || []).length} | Columns: ${(r.columns || []).length} | Time: ${(t1 - t0).toFixed(1)} ms`;
        setStatus('Query executed successfully.');
      } catch (err) {
        setStatus(`Query failed: ${err.message}`, true);
      }
    };

    document.getElementById('browseSelected').onclick = () => {
      if (selectedTable) {
        setActiveView('results');
        browseTable(selectedTable);
      }
    };

    document.getElementById('clearResult').onclick = () => {
      setActiveView('results');
      resultWrapEl.innerHTML = '';
      resultMetaEl.textContent = 'Result cleared.';
      setStatus('Ready.');
    };

    tabResultsEl.onclick = () => setActiveView('results');
    tabSchemaEl.onclick = () => setActiveView('schema');

    tableSearchEl.oninput = () => {
      renderTableList();
    };

    columnSearchEl.oninput = () => {
      renderTableList();
    };

    sqlInputEl.addEventListener('keydown', (e) => {
      if (autocompleteItems.length) {
        if (e.key === "ArrowDown") {
          e.preventDefault();
          setAutocompleteActive(autocompleteActiveIndex + 1);
          return;
        }
        if (e.key === "ArrowUp") {
          e.preventDefault();
          setAutocompleteActive(autocompleteActiveIndex - 1);
          return;
        }
        if (e.key === "Enter" && !(e.ctrlKey || e.metaKey)) {
          hideAutocomplete();
          return;
        }
        if (e.key === "Tab" && !(e.ctrlKey || e.metaKey)) {
          e.preventDefault();
          applyAutocomplete(autocompleteItems[Math.max(0, autocompleteActiveIndex)]);
          return;
        }
        if (e.key === "Escape") {
          e.preventDefault();
          hideAutocomplete();
          return;
        }
      }
      if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
        document.getElementById('runQuery').click();
      }
    });

    sqlInputEl.addEventListener('input', triggerAutocomplete);
    sqlInputEl.addEventListener('click', triggerAutocomplete);
    sqlInputEl.addEventListener('keyup', (e) => {
      if (["ArrowUp", "ArrowDown", "Enter", "Tab", "Escape", "Control", "Shift", "Alt", "Meta"].includes(e.key)) return;
      triggerAutocomplete();
    });
    sqlInputEl.addEventListener('blur', () => {
      setTimeout(() => {
        if (document.activeElement !== sqlInputEl) hideAutocomplete();
      }, 120);
    });

    autocompleteEl.addEventListener("mousedown", (e) => {
      e.preventDefault();
      const btn = e.target.closest(".sql-suggest");
      if (!btn) return;
      const idx = Number(btn.getAttribute("data-idx"));
      if (!Number.isNaN(idx) && autocompleteItems[idx]) applyAutocomplete(autocompleteItems[idx]);
    });

    document.addEventListener('mousedown', (e) => {
      if (!colMenuEl.classList.contains('show')) return;
      if (colMenuEl.contains(e.target)) return;
      if (e.target.closest('.col-menu-btn')) return;
      closeColumnMenu();
    });
    window.addEventListener('resize', closeColumnMenu);
    resultWrapEl.addEventListener('scroll', closeColumnMenu, { passive: true });
    whatsNewBtn.addEventListener('click', openWhatsNew);
    closeWhatsNewEl.addEventListener('click', closeWhatsNew);
    whatsNewModalEl.addEventListener('mousedown', (e) => {
      if (e.target === whatsNewModalEl) closeWhatsNew();
    });
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && whatsNewModalEl.classList.contains('show')) closeWhatsNew();
    });

    renderReleaseNotes();
    openWhatsNewIfFirstTimeForVersion();
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', init, { once: true });
    } else {
      init();
    }
  </script>

  <script id="seedSql" type="text/plain">
-- seed moved to external gold.sqlite
</script>
</body>
</html>











